# show_drives.sh	Display Labels and UUIDs of media
# LGD: Wed May 24 06:35:20 PDT 2017
# Re-write Fri Jun  9 04:31:03 PDT 2017
# Written as an exercise in shell script programming.  LDighera@att.net 
#

trap "setterm -foreground white;echo;exit 1" HUP 1 ERR INT QUIT TERM 15	# trap -l will display signals (bash only)

# Put commands in the environment as positional parameters to execute
set "lsblk -f" "lsblk -a" "fdisk -l" "findmnt -A" "findmnt -D" "findmnt -D -A" "df -Th"

# Prompt user for input
PRMPT="Enter to continue [Q]: "
WAIT(){
  ### ksh 'read' syntax: ksh man page line 2227 (vname?prompt) #### 
  [[ $(echo $SHELL |grep ksh) ]] && READ="read -n 1 REPLY?\"${PRMPT}\""	# ksh read syntax
  #### bash 'read' syntax: bash man page line 4335 (-p prompt) #### 
  [[ -n $BASH ]] && READ="read -n 1 -r -p \"${PRMPT}\""			# bash read syntax (-r, no varname)
  eval ${READ}								# Issue prompt for next page
  [[ $REPLY != [Qq]* ]] && setterm -foreground white && return		# Return to caller
  [[ $REPLY == [Qq]* ]] && setterm -foreground white			# User request to quit received
  echo -e "\033[0m";exit						# Set the Xterminal foreground=black; background=white
}

# Dynamically generate header and footer lines equal to the length of the longest line of the output of the current command with the command-name centered in the middle of the header line
GENLIN(){
  CMDLEN=$(echo "$1"|wc -m)						# The length of the current command
  LEN=$(eval "$1"|wc -L)						# The length of the longest line generated by the current command passed as an argument to this function
  MIDLIN=$((( ($LEN / 2) - $(echo $1|wc -m)+2 )))			# The mid-point of the line at which to place the current command in the header
  [[ $2 != "end" ]] && LEN=$((( $LEN - $CMDLEN )))			# Deduct the length of the command line from the header length for footer
  for i in $(seq $LEN) ;do						# Loop through the commands
    echo -e "=\c"							# Print each line characters
    [[ $i == $MIDLIN && $2 != "end" ]] && echo -e " $1 \c"		# Center the command-name in the header line
  done
  echo
}

CURROW=$(stty -a |grep rows|awk -F \; '/rows/ {print $2}'|tr -d '[a-z A-Z]')	# Get the number of terminal rows/lines (cursor row position at bottom of screen)
[[ -n $BASH ]] && CURROW=$((( $CURROW - 1 )))				# fucking bash :-)
while : ;do
  GENLIN "$1"								# Print output header line 
  eval "$1"								# Print command output
  GENLIN "$1" "end"							# Print output footer line
  echo
  shift									# Get the next command to run
  [[ -z $1 ]] && { echo;exit ;}						# Exit when command list is exhausted
  setterm -foreground green;WAIT;setterm -foreground white		# Color prompt for user input
  echo -e "\033[0m\c"							# Set Xterminal foreground=black; background=white
  tput cup $((($CURROW - 1))) 0						# Over-write the prompt line
done
exit 0
